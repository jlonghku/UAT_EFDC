MODULE INFOMOD
! ** AUTHOR: DH CHUNG

USE GLOBALVARS,ONLY:IK4
IMPLICIT NONE
CONTAINS

FUNCTION READSTR(UNIT) RESULT(STR)
  INTEGER(IK4),INTENT(IN) :: UNIT
  CHARACTER(200) :: STR
  INTEGER(IK4) :: ISTR,I
  DO WHILE (1)
    READ(UNIT,'(A)') STR
    STR = ADJUSTL(STR)
    ISTR = ICHAR(STR(1:1))
    
    I = 1
    DO WHILE (ISTR == 9) 
      I = I+1
      ISTR = ICHAR(STR(I:I))
    ENDDO
    
    SELECT CASE (ISTR)
    CASE (45,46,48:57)  !CHARACTER = -, ., 0:9
      BACKSPACE UNIT
      RETURN
    END SELECT
  ENDDO
END FUNCTION

 SUBROUTINE SKIPCOM(IUNIT,CC,IUOUT)
  INTEGER(4),  INTENT(IN) :: IUNIT    
  INTEGER(4),  INTENT(IN),OPTIONAL :: IUOUT
  CHARACTER(1),INTENT(IN) :: CC
  CHARACTER(200) :: LINE
  INTEGER(IK4) :: ISTR,I
  
  DO WHILE(1)
    READ(IUNIT, '(A)', END=999) LINE      
    IF (PRESENT(IUOUT)) WRITE(IUOUT,'(A)') LINE
    LINE = ADJUSTL(LINE)  
    ISTR = ICHAR(LINE(1:1))
    I = 1
    DO WHILE (ISTR == 9) 
      I = I+1
      ISTR = ICHAR(LINE(I:I))
    ENDDO
    IF(LINE(1:1) == CC.OR.(LINE(1:1) == 'C'.AND.LINE(2:2)/=':').OR.LINE(1:1) == 'c'.AND.LINE(2:2)/=':') THEN
      CYCLE
    ELSE
      BACKSPACE(IUNIT)
      EXIT
    ENDIF
  END DO
  999 RETURN
END SUBROUTINE

 FUNCTION NUMCOL(STR) RESULT(NC)
 INTEGER(4)::N,NC,NL,NLL
 CHARACTER(*)::STR,STR1*200
 STR1 = ADJUSTL(STR)
 NL = LEN_TRIM(STR1)
 IF (NL==0) THEN
   NC=0
   RETURN
 ENDIF
 
 DO N=1,NL
   IF (STR1(N:N)==',') STR1(N:N)=' '
 ENDDO
 NLL = LEN_TRIM(STR1)
 
 NC = 1
 DO N=2,NLL
   IF(STR1(N:N)==''.AND.STR1(N-1:N-1)/='') THEN
     NC=NC+1
   ENDIF
 ENDDO
 END FUNCTION
 
 SUBROUTINE ROOTFOLDER(FILENAME,FOLDER)
 USE IFPORT
 CHARACTER(*),INTENT(IN )::FILENAME
 CHARACTER(*),INTENT(OUT)::FOLDER
 CHARACTER($MAXPATH) ::FPATH
 CHARACTER(3)        ::DRIVE 
 CHARACTER(256)      ::DIR 
 CHARACTER(256)      ::NAME 
 CHARACTER(256)      ::EXT 
 CHARACTER(256)      ::FILE 
 INTEGER(4)          ::LENGTH 
 LENGTH = SPLITPATHQQ(FILENAME, DRIVE, DIR, NAME, EXT)
 FOLDER = TRIM(DRIVE)//DIR   
 IF (LENGTH<=0) THEN   
   PRINT*, TRIM(FILENAME)//' DOES NOT EXIST'      
   STOP       
 ENDIF
 END SUBROUTINE

 SUBROUTINE ROOTFOLDER_C(FILENAME,FOLDER)
 USE IFPORT
 CHARACTER(*),INTENT(IN )::FILENAME
 CHARACTER(*),INTENT(OUT)::FOLDER
 CHARACTER(256)      ::FPATH
 CHARACTER(3)        ::DRIVE 
 CHARACTER(256)      ::DIR 
 CHARACTER(256)      ::NAME 
 CHARACTER(256)      ::EXT 
 CHARACTER(256)      ::FILE,CURDIR*80
 INTEGER(4)          ::LENS,L,RES
 
 FOLDER = ''
 FPATH  = ADJUSTL(FILENAME)
 LENS   = LEN_TRIM(FPATH)
 L = -1
 DO L=LENS,1,-1
   IF(FPATH(L:L)=='/'.OR.FPATH(L:L)=='\') THEN
     FOLDER = FPATH(1:L)
     EXIT
   ENDIF
 ENDDO
 IF (LENS<=0) THEN   
   PRINT*, TRIM(FILENAME)//' DOES NOT EXIST'      
   STOP 
 ELSEIF (L==-1.AND.LENS>0) THEN
   RES = GETCWD(CURDIR)
   FOLDER = CURDIR    
 ENDIF
 END SUBROUTINE

 SUBROUTINE GETSTRNUM(STR,NM)
 ! ** GET NUMBERS IN A STRING WITH THE FORMAT:
 !**  M1:N1,K1,K2,M2:N2  OR M1:N1 K1 K2 M2:N2
 USE GLOBALVARS,ONLY:NSET
 CHARACTER(*),INTENT(IN )::STR
 INTEGER(4),  INTENT(OUT)::NM
 INTEGER(4)::N,NC,L,N1,N2,P,NUM1,NUM2
 CHARACTER(10),ALLOCATABLE::SS(:)
 CHARACTER(10)::NSTR
 
 NM = 0
 NC = NUMCOL(STR)
 ALLOCATE(SS(NC))
 READ(STR,*) (SS(N),N=1,NC)
 ! **
 NUM1=0
 DO N=1,NC
   L = SCAN(SS(N),':')
   IF (L>0) THEN
     NSTR = SS(N)
     NSTR(L:L) =' '
     READ(NSTR,*) N1,N2
     IF (N1<N2) THEN
       NUM2=NUM1+N2-N1+1
     ELSEIF(N1>N2) THEN
       NUM2=NUM1+N1-N2+1
     ENDIF
     NUM1=NUM2     
   ELSE
     READ(SS(N),*) N1
     NUM1 = NUM1+1
   ENDIF  
 ENDDO
 NM = NUM1
 
 ! **
 ALLOCATE(NSET(NM))
 NUM1=0
 DO N=1,NC
   L = SCAN(SS(N),':')
   IF (L>0) THEN
     SS(N)(L:L) =' '
     READ(SS(N),*) N1,N2
     IF (N1<N2) THEN
       NUM2=NUM1+N2-N1+1
     ELSEIF(N1>N2) THEN
       NUM2=NUM1+N1-N2+1
     ENDIF
     NSET(NUM1+1:NUM2) = (/(P,P=N1,N2)/)
     NUM1=NUM2     
   ELSE
     READ(SS(N),*) N1
     NUM1 = NUM1+1
     NSET(NUM1) = N1
   ENDIF  
 ENDDO
 NM = NUM1
 DEALLOCATE(SS)
 END SUBROUTINE
 
 SUBROUTINE ERRMES(IUNIT,IFILE)
 INTEGER(4),  INTENT (IN) :: IUNIT
 CHARACTER(*),INTENT(IN)  :: IFILE
 INTEGER(4) :: IOS
 
 READ(IUNIT,*,IOSTAT=IOS)
 IF (IOS /= 0 ) THEN
   PRINT*, 'READ FILE ERROR: '//TRIM(IFILE)
   PAUSE
   STOP
 ENDIF
 BACKSPACE(IUNIT)
 END SUBROUTINE
 
 SUBROUTINE REMOVTAB(STR)
 CHARACTER(*),INTENT(INOUT)::STR
 INTEGER(4)::L,LSTR
 
 STR  = ADJUSTL(STR)
 LSTR = LEN_TRIM(STR)
 DO L=1,LSTR
   IF (ICHAR(STR(L:L)) == 9) STR(L:L) = ''
 ENDDO
 STR = ADJUSTL(STR)
 END SUBROUTINE
 
END MODULE
 

